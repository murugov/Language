#include "generator.hpp"

// есть проблема со scanf для ';', '[', ']' 


hash_t bad_hash[] = {  
                        GetHash("("),      GetHash(")"),
                        GetHash("["),      GetHash("]"),
                        GetHash("{"),      GetHash("}"),
                        GetHash(","),      GetHash(";"),
                        GetHash(":"),      GetHash("="),
                        GetHash("=="),     GetHash("!="),
                        GetHash("<"),      GetHash(">"),
                        GetHash("<="),     GetHash(">="),
                        GetHash("def"),    GetHash("init"),
                        GetHash("if"),     GetHash("else"),
                        GetHash("while"),  GetHash("for"),
                        GetHash("return"), GetHash("EOF"),
                        GetHash("UNDEF")
                    };

static const size_t NUM_BAD_SYMS = sizeof(bad_hash) / sizeof(bad_hash[0]);


int main()
{
    FILE *SourceKeyFile  = fopen(PATH_TO_SRC_KEY_FILE, "r");
    if (IS_BAD_PTR(SourceKeyFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_KEY_FILE); return EXIT_FAILURE; }

    FILE *HashOpFile     = fopen(PATH_TO_HASH_OP_FILE, "w");
    if (IS_BAD_PTR(HashOpFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!\n" ANSI_COLOR_RESET, PATH_TO_HASH_OP_FILE); return EXIT_FAILURE; }
    
    FILE *OpInstrSetFile = fopen(PATH_TO_OP_INSTR_SET, "w");
    if (IS_BAD_PTR(OpInstrSetFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!\n" ANSI_COLOR_RESET, PATH_TO_OP_INSTR_SET); return EXIT_FAILURE; }

    FILE *KeywordSetFile = fopen(PATH_TO_KEYWORD_SET, "w");
    if (IS_BAD_PTR(KeywordSetFile)) { printf(ANSI_COLOR_RED "Bad pointer %s!\n" ANSI_COLOR_RESET, PATH_TO_KEYWORD_SET); return EXIT_FAILURE; }

    char* buffer = NULL;
    size_t len_buffer = 0;
    int count_line = 0;
    char **arr_ptr = TXTreader(SourceKeyFile, buffer, &len_buffer, &count_line, NULL);
    if (IS_BAD_PTR(arr_ptr)) printf(ANSI_COLOR_RED "Error reading %s!\n" ANSI_COLOR_RESET, PATH_TO_SRC_KEY_FILE);

    RemoveComments(arr_ptr, &count_line);

    if (GenHashOp(HashOpFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!\n" ANSI_COLOR_RESET, PATH_TO_HASH_OP_FILE);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    if (GenOpInstrSet(OpInstrSetFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!\n" ANSI_COLOR_RESET, PATH_TO_OP_INSTR_SET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    if (GenKeywordSet(KeywordSetFile, arr_ptr, count_line))
        printf(ANSI_COLOR_RED "Error creating %s!\n" ANSI_COLOR_RESET, PATH_TO_KEYWORD_SET);
    else
        printf(ANSI_COLOR_GREEN "SUCCESS\n" ANSI_COLOR_RESET);

    FreeLines(arr_ptr, count_line);
    fclose(SourceKeyFile);
    fclose(HashOpFile);
    fclose(OpInstrSetFile);
    fclose(KeywordSetFile);

    return 0;
}


GenErr_t GenHashOp(FILE *HashOpFile, char **arr_ptr, int count_line)
{
    if (IS_BAD_PTR(HashOpFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) 
        return GEN_ERROR;
        
    fprintf(HashOpFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    typedef struct {
        char name[32];
        char key_1[32];
        char key_2[32];
        hash_t hash;
    } func_info_t;
    
    func_info_t *func_infos = (func_info_t*)calloc((size_t)count_line, sizeof(func_info_t));
    if (IS_BAD_PTR(func_infos)) 
        return GEN_ERROR;

    int actual_count = 0;
    int max_name_len = 0;

    for (int line = 0; line < count_line; ++line)
    {
        if (arr_ptr[line] == NULL || *arr_ptr[line] == '\0' || *arr_ptr[line] == '#')
            continue;
        
        char *line_ptr = arr_ptr[line];
        
        while (*line_ptr == ' ' || *line_ptr == '\t') 
            line_ptr++;
        
        char *colon_ptr = strchr(line_ptr, ':');
        if (colon_ptr == NULL)
        {
            printf(ANSI_COLOR_RED "Error parsing line %d: no colon found in '%s'\n" ANSI_COLOR_RESET, 
                   line, arr_ptr[line]);
            free(func_infos);
            return GEN_ERROR;
        }
        
        size_t name_len = colon_ptr - line_ptr;
        if (name_len >= sizeof(func_infos[actual_count].name))
            name_len = sizeof(func_infos[actual_count].name) - 1;
        
        strncpy(func_infos[actual_count].name, line_ptr, name_len);
        func_infos[actual_count].name[name_len] = '\0';
        
        if (name_len > max_name_len)
            max_name_len = (int)name_len;
        
        line_ptr = colon_ptr + 1;
        
        char *quote1_ptr = strchr(line_ptr, '"');
        if (quote1_ptr == NULL)
        {
            printf(ANSI_COLOR_RED "Error parsing line %d: no first quote in '%s'\n" ANSI_COLOR_RESET, 
                   line, arr_ptr[line]);
            free(func_infos);
            return GEN_ERROR;
        }
        
        char *end_quote1_ptr = strchr(quote1_ptr + 1, '"');
        if (end_quote1_ptr == NULL)
        {
            printf(ANSI_COLOR_RED "Error parsing line %d: no closing quote for key1 in '%s'\n" ANSI_COLOR_RESET, 
                   line, arr_ptr[line]);
            free(func_infos);
            return GEN_ERROR;
        }
        
        size_t key1_len = end_quote1_ptr - (quote1_ptr + 1);
        if (key1_len >= sizeof(func_infos[actual_count].key_1))
            key1_len = sizeof(func_infos[actual_count].key_1) - 1;
        
        strncpy(func_infos[actual_count].key_1, quote1_ptr + 1, key1_len);
        func_infos[actual_count].key_1[key1_len] = '\0';
        
        char *quote2_ptr = strchr(end_quote1_ptr + 1, '"');
        if (quote2_ptr == NULL)
        {
            printf(ANSI_COLOR_RED "Error parsing line %d: no second quote in '%s'\n" ANSI_COLOR_RESET, 
                   line, arr_ptr[line]);
            free(func_infos);
            return GEN_ERROR;
        }
        
        char *end_quote2_ptr = strchr(quote2_ptr + 1, '"');
        if (end_quote2_ptr == NULL)
        {
            printf(ANSI_COLOR_RED "Error parsing line %d: no closing quote for key2 in '%s'\n" ANSI_COLOR_RESET, 
                   line, arr_ptr[line]);
            free(func_infos);
            return GEN_ERROR;
        }
        
        size_t key2_len = end_quote2_ptr - (quote2_ptr + 1);
        if (key2_len >= sizeof(func_infos[actual_count].key_2))
            key2_len = sizeof(func_infos[actual_count].key_2) - 1;
        
        strncpy(func_infos[actual_count].key_2, quote2_ptr + 1, key2_len);
        func_infos[actual_count].key_2[key2_len] = '\0';
        
        if (key2_len == 1)
            func_infos[actual_count].hash = (hash_t)(*func_infos[actual_count].key_2);
        else
            func_infos[actual_count].hash = GetHash(func_infos[actual_count].key_2);

        actual_count++;
    }

    fprintf(HashOpFile, "#ifndef HASH_OP_HPP\n"
                        "#define HASH_OP_HPP\n\n\n");

    fprintf(HashOpFile, "enum HashOp\n");
    fprintf(HashOpFile, "{\n");

    for (int i = 0; i < actual_count - 1; ++i)
        fprintf(HashOpFile, "\tHASH_%-*s = 0x%lX,\n", 
                max_name_len, func_infos[i].name, 
                (unsigned long)func_infos[i].hash);
    
    if (actual_count > 0)
        fprintf(HashOpFile, "\tHASH_%-*s = 0x%lX\n", 
                max_name_len, func_infos[actual_count - 1].name, 
                (unsigned long)func_infos[actual_count - 1].hash);

    fprintf(HashOpFile, "};\n\n");

    fprintf(HashOpFile, "struct calc_context\n");
    fprintf(HashOpFile, "{\n");
    fprintf(HashOpFile, "    double left_val;\n");
    fprintf(HashOpFile, "    double right_val;\n");
    fprintf(HashOpFile, "};\n\n");
    
    fprintf(HashOpFile, "struct diff_context\n");
    fprintf(HashOpFile, "{\n");
    fprintf(HashOpFile, "    node_t *node_left;\n");
    fprintf(HashOpFile, "    node_t *node_right;\n");
    fprintf(HashOpFile, "    hash_t hash_indep_var;\n");
    fprintf(HashOpFile, "};\n\n\n");
    
    for (int i = 0; i < actual_count; ++i)
    {
        if (!bsearch(&func_infos[i].hash, bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash))
        {
            fprintf(HashOpFile, "double calc%s(calc_context *calc_params);\n", 
                    func_infos[i].name);
            fprintf(HashOpFile, "node_t *diff%s(diff_context *diff_params);\n\n", 
                    func_infos[i].name);
        }
    }

    fprintf(HashOpFile, "typedef double (*calc_t)(calc_context *calc_params);\n");
    fprintf(HashOpFile, "typedef node_t *(*diff_t)(diff_context *diff_params);\n\n\n");
    
    fprintf(HashOpFile, "#endif\n");

    free(func_infos);
    return GEN_SUCCESS;
}


GenErr_t GenOpInstrSet(FILE *OpInstrSetFile, char **arr_ptr, int count_line)
{
    if (IS_BAD_PTR(OpInstrSetFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) return GEN_ERROR;
        
    fprintf(OpInstrSetFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    fprintf(OpInstrSetFile, "const op_t op_instr_set[] =\n");
    fprintf(OpInstrSetFile, "{\n");

    static const hash_t HASH_LOG   = GetHash("LOG");
    static const hash_t HASH_PLUS  = GetHash("+");
    static const hash_t HASH_MINUS = GetHash("-");
    static const hash_t HASH_MUL   = GetHash("*");
    static const hash_t HASH_DIV   = GetHash("/");
    static const hash_t HASH_POW   = GetHash("^");
    
    op_instr_t *func_infos = (op_instr_t*)calloc((size_t)count_line, sizeof(op_instr_t));
    if (IS_BAD_PTR(func_infos)) return GEN_ERROR;

    int actual_count = 0;
    size_t max_name_len = 0;
    size_t max_op_len = 0;
    int max_num_width = 0;

    for (int line = 0; line < count_line; ++line)
    {
        if (*arr_ptr[line] == '\0') 
            continue;
        
        if (sscanf(arr_ptr[line], "%15[^:]: \"%15[^\"]\";", 
                   func_infos[actual_count].name, 
                   func_infos[actual_count].op) == 2)
        {
            hash_t target_hash = GetHash(func_infos[actual_count].op);
            if (bsearch(&target_hash, bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash)) continue;
            
            size_t name_len = strlen(func_infos[actual_count].name);
            size_t op_len   = strlen(func_infos[actual_count].op);
            
            if (name_len > max_name_len) max_name_len = name_len;
            if (op_len > max_op_len) max_op_len = op_len;
            
            func_infos[actual_count].hash = target_hash;
            
            hash_t op_hash = func_infos[actual_count].hash;
            hash_t name_hash = GetHash(func_infos[actual_count].name);
            
            if (name_hash == HASH_LOG || op_hash == HASH_PLUS || 
                op_hash == HASH_MINUS || op_hash == HASH_MUL || 
                op_hash == HASH_DIV || op_hash == HASH_POW)
            {
                func_infos[actual_count].num_args = 2;
            }
            else
            {
                func_infos[actual_count].num_args = 1;
            }
            
            if (func_infos[actual_count].num_args > max_num_width)
                max_num_width = func_infos[actual_count].num_args;
            
            actual_count++;
        }
    }
    
    qsort(func_infos, (size_t)actual_count, sizeof(op_instr_t), CmpOpInstrSetByHash);

    for (int i = 0; i < actual_count - 1; ++i)
    {
        fprintf(OpInstrSetFile, 
                "\t{HASH_%-*s, \"%s\",%*d, calc%s, diff%s},\n",
                (int)max_name_len, func_infos[i].name, 
                func_infos[i].op,
                max_num_width + 1, 
                func_infos[i].num_args,
                func_infos[i].name, 
                func_infos[i].name);
    }
    
    if (actual_count > 0)
    {
        fprintf(OpInstrSetFile,
                "\t{HASH_%-*s, \"%s\",%*d, calc%s, diff%s}\n",
                (int)max_name_len, func_infos[actual_count - 1].name,
                func_infos[actual_count - 1].op,
                max_num_width + 1,
                func_infos[actual_count - 1].num_args,
                func_infos[actual_count - 1].name,
                func_infos[actual_count - 1].name);
    }

    fprintf(OpInstrSetFile, "};\n\n");
    
    fprintf(OpInstrSetFile, "#define LEN_INSTR_SET sizeof(op_instr_set) / sizeof(*op_instr_set)\n");

    free(func_infos);
    return GEN_SUCCESS;
}


GenErr_t GenKeywordSet(FILE *KeywordSetFile, char **arr_ptr, int count_line)
{
    if (IS_BAD_PTR(KeywordSetFile) || IS_BAD_PTR(arr_ptr) || count_line < 0) 
        return GEN_ERROR;
        
    fprintf(KeywordSetFile, "// Automatically generated by Andrey Murugov's code-generator. Do not edit!!!\n\n");
    
    qsort(bad_hash, NUM_BAD_SYMS, sizeof(hash_t), CmpByHash);

    fprintf(KeywordSetFile, "const keyword_t keyword_set[] =\n");
    fprintf(KeywordSetFile, "{\n");
    
    keyword_set_t *func_infos = (keyword_set_t*)calloc((size_t)count_line, sizeof(keyword_set_t));
    if (IS_BAD_PTR(func_infos)) 
        return GEN_ERROR;

    int actual_count    = 0;
    size_t max_name_len = 0;
    size_t max_key_len  = 0;

    for (int line = 0; line < count_line; ++line)
    {
        if (arr_ptr[line] == NULL || *arr_ptr[line] == '\0' || *arr_ptr[line] == '#')
            continue;
        
        char *line_ptr = arr_ptr[line];
        
        while (*line_ptr == ' ' || *line_ptr == '\t') 
            line_ptr++;
        
        char *colon_ptr = strchr(line_ptr, ':');
        if (colon_ptr == NULL)
            continue;
            
        size_t name_len = colon_ptr - line_ptr;
        if (name_len >= sizeof(func_infos[actual_count].name))
            name_len = sizeof(func_infos[actual_count].name) - 1;
        
        strcpy(func_infos[actual_count].name, line_ptr);
        func_infos[actual_count].name[name_len] = '\0';
        
        line_ptr = colon_ptr + 1;
        
        char *quote1_ptr = strchr(line_ptr, '"');
        if (quote1_ptr == NULL)
            continue;
            
        char *end_quote1_ptr = strchr(quote1_ptr + 1, '"');
        if (end_quote1_ptr == NULL)
            continue;
            
        size_t key1_len = end_quote1_ptr - (quote1_ptr + 1);
        if (key1_len >= sizeof(func_infos[actual_count].key_1))
            key1_len = sizeof(func_infos[actual_count].key_1) - 1;
        
        strcpy(func_infos[actual_count].key_1, quote1_ptr + 1);
        func_infos[actual_count].key_1[key1_len] = '\0';
        
        char *quote2_ptr = strchr(end_quote1_ptr + 1, '"');
        if (quote2_ptr == NULL)
            continue;
            
        char *end_quote2_ptr = strchr(quote2_ptr + 1, '"');
        if (end_quote2_ptr == NULL)
            continue;
            
        size_t key2_len = end_quote2_ptr - (quote2_ptr + 1);
        if (key2_len >= sizeof(func_infos[actual_count].key_2))
            key2_len = sizeof(func_infos[actual_count].key_2) - 1;
        
        strcpy(func_infos[actual_count].key_2, quote2_ptr + 1);
        func_infos[actual_count].key_2[key2_len] = '\0';
        
        if (name_len > max_name_len) 
            max_name_len = name_len;
        if (key2_len > max_key_len) 
            max_key_len = key2_len;
        
        if (key2_len == 1)
            func_infos[actual_count].hash = (hash_t)(*func_infos[actual_count].key_2);
        else
            func_infos[actual_count].hash = GetHash(func_infos[actual_count].key_2);

        actual_count++;
    }
    
    qsort(func_infos, (size_t)actual_count, sizeof(keyword_set_t), CmpKeywordSetByHash);

    for (int i = 0; i < actual_count - 1; ++i)
    {
        fprintf(KeywordSetFile, 
                "\t{\"%s\",\t%zu ,\t0x%zX ,\t\"%s\",\t%zu ,\t0x%zX},\n",
                func_infos[i].key_2,
                strlen(func_infos[i].key_2),
                func_infos[i].hash,
                func_infos[i].key_1,
                strlen(func_infos[i].key_1),
                GetHash(func_infos[i].key_1));
    }
    
    if (actual_count > 0)
    {
        fprintf(KeywordSetFile, 
                "\t{\"%s\",\t%zu ,\t0x%zX ,\t\"%s\",\t%zu ,\t0x%zX}\n",
                func_infos[actual_count - 1].key_2,
                strlen(func_infos[actual_count - 1].key_2),
                func_infos[actual_count - 1].hash,
                func_infos[actual_count - 1].key_1,
                strlen(func_infos[actual_count - 1].key_1),
                GetHash(func_infos[actual_count - 1].key_1));
    }

    fprintf(KeywordSetFile, "};\n\n");
    
    fprintf(KeywordSetFile, "#define LEN_KEYWORD_SET sizeof(keyword_set) / sizeof(*keyword_set)\n");

    free(func_infos);
    return GEN_SUCCESS;
}


int CmpOpInstrSetByHash(const void *a, const void *b)
{
    const op_instr_t *op_instr_a = (const op_instr_t*)a;
    const op_instr_t *op_instr_b = (const op_instr_t*)b;

    if (op_instr_a->hash > op_instr_b->hash)
        return 1;
    if (op_instr_a->hash == op_instr_b->hash)
        return 0;
    return -1;
}


int CmpKeywordSetByHash(const void *a, const void *b)
{
    const keyword_set_t *keyword_a = (const keyword_set_t*)a;
    const keyword_set_t *keyword_b = (const keyword_set_t*)b;

    if (keyword_a->hash > keyword_b->hash)
        return 1;
    if (keyword_a->hash == keyword_b->hash)
        return 0;
    return -1;
}


int CmpByHash(const void *a, const void *b)
{
    const hash_t *hash_a = (const hash_t*)a;
    const hash_t *hash_b = (const hash_t*)b;

    if (*hash_a > *hash_b)
        return 1;
    if (*hash_a == *hash_b)
        return 0;
    return -1;
}


void RemoveComments(char** arr_ptr, int *count_line)
{
    for (int i = 0; i < *count_line; ++i)
    {
        char* colon = strchr(arr_ptr[i], '#');

        if (colon != NULL)
            *colon = '\0';
    }
}